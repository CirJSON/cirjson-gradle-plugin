package org.cirjson.compiler.resolve

import org.cirjson.compiler.diagnostic.SERIALIZABLE_PROPERTIES
import org.cirjson.compiler.extensions.SerializationDescriptorSerializerPlugin
import org.cirjson.compiler.resolve.SerializationAnnotations.serializableAnnotationFqName
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.Annotated
import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptorImpl
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.metadata.SerializationPluginMetadataExtensions
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.platform.isJs
import org.jetbrains.kotlin.platform.isWasm
import org.jetbrains.kotlin.platform.konan.isNative
import org.jetbrains.kotlin.psi.KtAnnotationEntry
import org.jetbrains.kotlin.psi.KtDeclarationWithInitializer
import org.jetbrains.kotlin.psi.KtParameter
import org.jetbrains.kotlin.psi.ValueArgument
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.constants.KClassValue
import org.jetbrains.kotlin.resolve.descriptorUtil.classId
import org.jetbrains.kotlin.resolve.descriptorUtil.module
import org.jetbrains.kotlin.resolve.descriptorUtil.platform
import org.jetbrains.kotlin.resolve.lazy.descriptors.LazyAnnotationDescriptor
import org.jetbrains.kotlin.resolve.source.getPsi
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedClassDescriptor
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedPropertyDescriptor
import org.jetbrains.kotlin.serialization.deserialization.getName
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.types.typeUtil.isSubtypeOf
import org.jetbrains.kotlin.utils.addToStdlib.runIf

fun PropertyDescriptor.declaresDefaultValue(): Boolean {
    when (val declaration = this.source.getPsi()) {
        is KtDeclarationWithInitializer -> return declaration.initializer != null
        is KtParameter -> return declaration.defaultValue != null
        is Any -> return false // Not-null check
    } // PSI is null, property is from another module
    if (this !is DeserializedPropertyDescriptor) return false
    val myClassCtor = (this.containingDeclaration as? ClassDescriptor)?.unsubstitutedPrimaryConstructor
            ?: return false // If property is a constructor parameter, check parameter default value // (serializable classes always have parameters-as-properties, so no name clash here)
    if (myClassCtor.valueParameters.find { it.name == this.name }
                ?.declaresDefaultValue() == true) return true // If it is a body property, then it is likely to have initializer when getter is not specified
    // note this approach is not working well if we have smth like `get() = field`, but such cases on cross-module boundaries
    // should be very marginal. If we want to solve them, we need to add protobuf metadata extension.
    return getter?.isDefault == true
}

fun BindingContext.serializablePropertiesFor(classDescriptor: ClassDescriptor,
        serializationDescriptorSerializer: SerializationDescriptorSerializerPlugin? = null): SerializableProperties {
    val props = this.get(SERIALIZABLE_PROPERTIES, classDescriptor) ?: SerializableProperties(classDescriptor, this)
    serializationDescriptorSerializer?.putIfNeeded(classDescriptor, props)
    return props
}

fun <P : ISerializableProperty> restoreCorrectOrderFromClassProtoExtension(descriptor: ClassDescriptor,
        props: List<P>): List<P> {
    if (descriptor !is DeserializedClassDescriptor) return props
    val correctOrder: List<Name> =
            descriptor.classProto.getExtension(SerializationPluginMetadataExtensions.propertiesNamesInProgramOrder)
                .map { descriptor.c.nameResolver.getName(it) }
    val propsMap = props.associateBy { it.originalDescriptorName }
    return correctOrder.map { propsMap.getValue(it) }
}

fun isAllowedToHaveAutoGeneratedSerializerMethods(classDescriptor: ClassDescriptor,
        serializableClassDescriptor: ClassDescriptor): Boolean {
    if (serializableClassDescriptor.isSerializableEnum()) return true // don't generate automatically anything for enums or interfaces or other strange things
    if (serializableClassDescriptor.kind != ClassKind.CLASS) return false // it is either GeneratedSerializer implementation
    // or user implementation which does not have type parameters (to be able to correctly initialize descriptor)
    return classDescriptor.typeConstructor.supertypes.any(
            ::isGeneratedKSerializer) || (classDescriptor.typeConstructor.supertypes.any(
            ::isKSerializer) && classDescriptor.declaredTypeParameters.isEmpty())
}

fun isKSerializer(type: KotlinType?): Boolean =
        type != null && KotlinBuiltIns.isConstructedFromGivenClass(type, SerialEntityNames.KSERIALIZER_NAME_FQ)

fun isGeneratedKSerializer(type: KotlinType?): Boolean =
        type != null && KotlinBuiltIns.isConstructedFromGivenClass(type, SerialEntityNames.GENERATED_SERIALIZER_FQ)

fun ClassDescriptor.getGeneratedSerializerDescriptor(): ClassDescriptor =
        module.getClassFromInternalSerializationPackage(SerialEntityNames.GENERATED_SERIALIZER_CLASS.identifier)

fun ClassDescriptor.createSerializerTypeFor(argument: SimpleType, baseSerializerInterface: FqName): SimpleType {
    val projectionType = Variance.INVARIANT
    val types = listOf(TypeProjectionImpl(projectionType, argument))
    val descriptor = module.findClassAcrossModuleDependencies(ClassId.topLevel(baseSerializerInterface))
            ?: throw IllegalArgumentException(
                    "Can't locate $baseSerializerInterface. Is kotlinx-serialization library present in compile classpath?")
    return KotlinTypeFactory.simpleNotNullType(TypeAttributes.Empty, descriptor, types)
}

fun extractKSerializerArgumentFromImplementation(implementationClass: ClassDescriptor): KotlinType? {
    val supertypes = implementationClass.typeConstructor.supertypes
    val kSerializerSupertype =
            supertypes.find { isGeneratedKSerializer(it) } ?: supertypes.find { isKSerializer(it) } ?: return null
    return kSerializerSupertype.arguments.first().type
}

fun Annotations.serializableWith(module: ModuleDescriptor): KotlinType? =
        this.findAnnotationKotlinTypeValue(serializableAnnotationFqName, module, "with")

fun ClassDescriptor.isSerializableEnum(): Boolean = kind == ClassKind.ENUM_CLASS && hasSerializableOrMetaAnnotation

fun ClassDescriptor.isEnumWithLegacyGeneratedSerializer(): Boolean =
        isInternallySerializableEnum() && useGeneratedEnumSerializer

fun ClassDescriptor.isInternallySerializableEnum(): Boolean =
        kind == ClassKind.ENUM_CLASS && hasSerializableOrMetaAnnotationWithoutArgs

fun ClassDescriptor.enumEntries(): List<ClassDescriptor> {
    check(this.kind == ClassKind.ENUM_CLASS)
    return unsubstitutedMemberScope.getContributedDescriptors().asSequence().filterIsInstance<ClassDescriptor>()
        .filter { it.kind == ClassKind.ENUM_ENTRY }.toList()
}

// check enum or its elements has any SerialInfo annotation
fun ClassDescriptor.isEnumWithSerialInfoAnnotation(): Boolean {
    if (kind != ClassKind.ENUM_CLASS) return false
    if (annotations.hasAnySerialAnnotation) return true
    return enumEntries().any { (it.annotations.hasAnySerialAnnotation) }
}

internal fun Annotated.findSerializableAnnotationDeclaration(): KtAnnotationEntry? {
    val lazyDesc = annotations.findAnnotation(serializableAnnotationFqName) as? LazyAnnotationDescriptor
    return lazyDesc?.annotationEntry
}

fun Annotated.findSerializableOrMetaAnnotationDeclaration(): KtAnnotationEntry? {
    val lazyDesc = (annotations.findAnnotation(serializableAnnotationFqName)
            ?: annotations.firstOrNull { it.isMetaSerializableAnnotation }) as? LazyAnnotationDescriptor
    return lazyDesc?.annotationEntry
}

fun Annotated.findAnnotationDeclaration(fqName: FqName): KtAnnotationEntry? {
    val lazyDesc = annotations.findAnnotation(fqName) as? LazyAnnotationDescriptor
    return lazyDesc?.annotationEntry
}

// For abstract classes marked with @Serializable,
// methods are generated anyway, although they shouldn't have
// generated $serializer and use Polymorphic one.
fun ClassDescriptor.isAbstractOrSealedSerializableClass(): Boolean =
        isInternalSerializable && (modality == Modality.ABSTRACT || modality == Modality.SEALED)

fun ClassDescriptor.polymorphicSerializerIfApplicableAutomatically(): ClassDescriptor? {
    val serializer = when {
        kind == ClassKind.INTERFACE && modality == Modality.SEALED -> SpecialBuiltins.sealedSerializer
        kind == ClassKind.INTERFACE -> SpecialBuiltins.polymorphicSerializer
        isInternalSerializable && modality == Modality.ABSTRACT -> SpecialBuiltins.polymorphicSerializer
        isInternalSerializable && modality == Modality.SEALED -> SpecialBuiltins.sealedSerializer
        else -> null
    }
    return serializer?.let { module.getClassFromSerializationPackage(it) }
}

// returns only user-overridden Serializer
fun KotlinType.overriddenSerializer(module: ModuleDescriptor): KotlinType? {
    annotations.serializableWith(module)?.let { return it }
    val desc = this.toClassDescriptor ?: return null
    desc.serializableWith?.let { return it }
    return null
}

fun getSerializableClassDescriptorByCompanion(thisDescriptor: ClassDescriptor): ClassDescriptor? {
    if (thisDescriptor.isSerializableObject) return thisDescriptor
    if (!thisDescriptor.isCompanionObject) return null
    val classDescriptor = (thisDescriptor.containingDeclaration as? ClassDescriptor) ?: return null
    if (!classDescriptor.shouldHaveGeneratedMethodsInCompanion) return null
    return classDescriptor
}

fun ClassDescriptor.needSerializerFactory(): Boolean {
    if (!(this.platform?.isNative() == true || this.platform.isJs() || this.platform.isWasm())) return false
    val serializableClass = getSerializableClassDescriptorByCompanion(this) ?: return false
    if (serializableClass.isSerializableObject) return true
    if (serializableClass.isSerializableEnum()) return true
    if (serializableClass.isAbstractOrSealedSerializableClass()) return true
    if (serializableClass.isSealedSerializableInterface) return true
    return !serializableClass.declaredTypeParameters.isEmpty()
}

fun DeclarationDescriptor.jsExportIgnore(): AnnotationDescriptor? {
    val jsExportIgnore = runIf(platform.isJs()) { module.getJsExportIgnore() } ?: return null
    return AnnotationDescriptorImpl(jsExportIgnore.defaultType, mapOf(), jsExportIgnore.source)
}

fun getSerializableClassDescriptorBySerializer(serializerDescriptor: ClassDescriptor): ClassDescriptor? {
    val serializerForClass = serializerDescriptor.serializerForClass
    if (serializerForClass != null) return serializerForClass.toClassDescriptor
    if (serializerDescriptor.name !in setOf(SerialEntityNames.SERIALIZER_CLASS_NAME,
                    SerialEntityNames.GENERATED_SERIALIZER_CLASS)) return null
    val classDescriptor = (serializerDescriptor.containingDeclaration as? ClassDescriptor) ?: return null
    if (!classDescriptor.shouldHaveGeneratedSerializer) return null
    return classDescriptor
}

fun ClassDescriptor.checkSerializableClassPropertyResult(prop: PropertyDescriptor): Boolean =
        prop.returnType!!.isSubtypeOf(
                getClassFromSerializationPackage(SerialEntityNames.SERIAL_DESCRIPTOR_CLASS).toSimpleType(
                        false)) // todo: cache lookup

// todo: serialization: do an actual check better that just number of parameters
fun ClassDescriptor.checkSaveMethodParameters(parameters: List<ValueParameterDescriptor>): Boolean =
        parameters.size == 2

fun ClassDescriptor.checkSaveMethodResult(type: KotlinType): Boolean = KotlinBuiltIns.isUnit(type)

// todo: serialization: do an actual check better that just number of parameters
fun ClassDescriptor.checkLoadMethodParameters(parameters: List<ValueParameterDescriptor>): Boolean =
        parameters.size == 1

fun ClassDescriptor.checkLoadMethodResult(type: KotlinType): Boolean =
        getSerializableClassDescriptorBySerializer(this)?.defaultType == type

fun ClassConstructorDescriptor.isSerializationCtor(): Boolean {/*kind == CallableMemberDescriptor.Kind.SYNTHESIZED does not work because DeserializedClassConstructorDescriptor loses its kind*/
    return valueParameters.lastOrNull()?.run {
        name == SerialEntityNames.dummyParamName && type.constructor.declarationDescriptor?.classId == ClassId(
                SerializationPackages.internalPackageFqName, SerialEntityNames.SERIAL_CTOR_MARKER_NAME)
    } == true
}

// finds constructor (KSerializer<T0>, KSerializer<T1>...) on a KSerializer<T<T0, T1...>>
fun findSerializerConstructorForTypeArgumentsSerializers(serializerDescriptor: ClassDescriptor,
        onlyIfSynthetic: Boolean = false): ClassConstructorDescriptor? {
    val serializableImplementationTypeArguments =
            extractKSerializerArgumentFromImplementation(serializerDescriptor)?.arguments ?: throw AssertionError(
                    "Serializer does not implement KSerializer??")

    val typeParamsCount = serializableImplementationTypeArguments.size
    if (typeParamsCount == 0) return null //don't need it
    val ctor = serializerDescriptor.constructors.find { ctor ->
        ctor.valueParameters.size == typeParamsCount && ctor.valueParameters.all { isKSerializer(it.type) }
    }
    return if (!onlyIfSynthetic) ctor else ctor?.takeIf { it.kind == CallableMemberDescriptor.Kind.SYNTHESIZED }
}

fun AnnotationDescriptor.findAnnotationEntry(): KtAnnotationEntry? =
        (this as? LazyAnnotationDescriptor)?.annotationEntry

inline fun <reified R> Annotations.findAnnotationConstantValue(annotationFqName: FqName, property: String): R? =
        findAnnotation(annotationFqName)?.findConstantValue(property)

inline fun <reified R> AnnotationDescriptor.findConstantValue(property: String): R? =
        allValueArguments.entries.singleOrNull { it.key.asString() == property }?.value?.value as? R

fun Annotations.findAnnotationKotlinTypeValue(annotationFqName: FqName, moduleForResolve: ModuleDescriptor,
        property: String): KotlinType? = findAnnotation(annotationFqName)?.let { annotation ->
    val maybeKClass =
            annotation.allValueArguments.entries.singleOrNull { it.key.asString() == property }?.value as? KClassValue
    maybeKClass?.getArgumentType(moduleForResolve)
}

fun ClassDescriptor.getKSerializerConstructorMarker(): ClassDescriptor = module.findClassAcrossModuleDependencies(
        ClassId(SerializationPackages.internalPackageFqName, SerialEntityNames.SERIAL_CTOR_MARKER_NAME))!!

fun ClassDescriptor.getKSerializer(): ClassDescriptor = module.findClassAcrossModuleDependencies(
        ClassId(SerializationPackages.packageFqName, SerialEntityNames.KSERIALIZER_NAME))!!

fun ModuleDescriptor.getJsExportIgnore(): ClassDescriptor? =
        findClassAcrossModuleDependencies(SerializationJsDependenciesClassIds.jsExportIgnore)

fun getInternalPackageFqn(classSimpleName: String): FqName =
        SerializationPackages.internalPackageFqName.child(Name.identifier(classSimpleName))

fun ModuleDescriptor.getClassFromInternalSerializationPackage(classSimpleName: String) = requireNotNull(
        findClassAcrossModuleDependencies(ClassId(SerializationPackages.internalPackageFqName, Name.identifier(
                classSimpleName)))) { "Can't locate class $classSimpleName from package ${SerializationPackages.internalPackageFqName}" }

fun ModuleDescriptor.getClassFromSerializationDescriptorsPackage(classSimpleName: String) = requireNotNull(
        findClassAcrossModuleDependencies(ClassId(SerializationPackages.descriptorsPackageFqName, Name.identifier(
                classSimpleName)))) { "Can't locate class $classSimpleName from package ${SerializationPackages.descriptorsPackageFqName}" }

fun getSerializationPackageFqn(classSimpleName: String): FqName =
        SerializationPackages.packageFqName.child(Name.identifier(classSimpleName))

fun ModuleDescriptor.getClassFromSerializationPackage(classSimpleName: String) =
        SerializationPackages.allPublicPackages.firstNotNullOfOrNull { pkg ->
            module.findClassAcrossModuleDependencies(ClassId(pkg, Name.identifier(classSimpleName)))
        } ?: throw IllegalArgumentException("Can't locate class $classSimpleName")

fun ClassDescriptor.getClassFromSerializationPackage(classSimpleName: String) =
        module.getClassFromSerializationPackage(classSimpleName)

fun ClassDescriptor.getClassFromInternalSerializationPackage(classSimpleName: String) =
        module.getClassFromInternalSerializationPackage(classSimpleName)

fun ClassDescriptor.toSimpleType(nullable: Boolean = false) =
        KotlinTypeFactory.simpleType(TypeAttributes.Empty, this.typeConstructor, emptyList(), nullable)

fun Annotated.annotationsWithArguments(): List<Triple<ClassDescriptor, List<ValueArgument>, List<ValueParameterDescriptor>>> =
        annotations.asSequence().filter { it.type.toClassDescriptor?.isSerialInfoAnnotation == true }
            .filterIsInstance<LazyAnnotationDescriptor>().mapNotNull { annDesc ->
                annDesc.type.toClassDescriptor?.let {
                    Triple(it, annDesc.annotationEntry.valueArguments,
                            it.unsubstitutedPrimaryConstructor?.valueParameters.orEmpty())
                }
            }.toList()
